// 문제
//정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
// 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
// 2. X가 2로 나누어 떨어지면, 2로 나눈다.
// 3. 1을 뺀다.
//정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

//첫째 줄에 1보다 크거나 같고, 10^6 보다 작거나 같은 정수 N이 주어진다.

// 풀이과정 생각해보기
// 1. 연산에 대한 3가지 경우의 수를 작성해보고 조건에 따라 출력한다...?

// 풀이과정
//1. 조건을 이용해서 확인해보기
// => 5일 때
// 1 
// 2 3회(2로 나누어 떨어짐)
// 3
// 4 2회(2로 나누어 떨어짐)
// 5 1회(-1)
// 총 3회

// => 10일 경우
// 1
// 2
// 3 3회(3으로 나누어 떨어짐)
// 4
// 5
// 6
// 7
// 8
// 9  2회(3으로 나누어 떨어짐)
// 10 1회(-1)
// 총 3회

// 2. 위 조건에서 확인한 내용을 코드화 시키기
// 2-1. X가 3으로 나누어 떨어질 때 최소값 => X[i]=Math.min(X[i],X[i/3]+1)
// 2-2. X가 2로 나누어 떨어질 때 최소값 => X[i]=Math.min(X[i],X[i/2]+1)
// 2-3. X가 1을 뺄 때 => X[i]=X[i-1]+1
// 3. 반복문을 통해 해결할 수 있도록 빈 배열을 만든다.
// 4. 1을 만들어야 하기 때문에 반목문 i는 2부터 n까지 돌아간다.
// 5. 모든 조건을 만족해서 해결이 되었을 때 배열 X에서 n 번째 인덱스를 추출한다.


function solution(n){
  let X = new Array(n+1).fill(0)
    for(let i=2; i<=n; i++){
      X[i]=X[i-1]+1
      if(i%3 === 0){
        X[i]=Math.min(X[i],X[i/3]+1)
      }
      if(i%2===0){
        X[i]=Math.min(X[i],X[i/2]+1)
      }
    }
  return X[n]
  }
  
  solution(5)