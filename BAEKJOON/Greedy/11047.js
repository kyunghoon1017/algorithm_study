// 1. 동전의 종류는 총 N개이고 K를 만들어야하는데 이때의 최소 값(result)을 구한다.
// (예시 : const N = [10,100,500], K=710원일 때 => result = 총 3개(500원 1개 100원 1개 10원 1개))

// 2. 첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)
//둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

// 풀이 과정 생각해보기
//1. 동전의 가치가 가장 큰 동전부터 사용한다.
//2. 그러기 위해서 동전의 가치를 내림차순 정렬한다.(sort사용)
//3. 동전의 배열을 순회하는 반복문을 사용해본다.
//4. 반복문을 순회하면서 결과값 result가 나오면 멈추고 result를 리턴한다.

// 풀이과정
// 1. 동전의 가치가 큰 동전부터 사용한다.(동전배열 N을 내림차순 정렬)
// 2. 동전의 배열 N을 순회하는 반목문을 사용한다.
// 2-1. 조건 1. 배열 N의 각 요소들은 K의 값보다 크면 안됨(가치가 큰 동전부터 사용하기 위해서)
//3. 사용한 동전의 개수를 파악하기 위해 변수를 만들어 초기값 0을 준다.
//4. 개수를 파악하기 위한 변수에 K를 N[i]만큼 나누어 사용한 개수를 파악한다.
//5. 마지막으로 K의 값이 맞아 떨어지도록 N[i]와 나눈 나머지 값이 같도록 만들어준다.


const coinChange = (N,K) =>{
  N.sort((a,b)=>{
    return b-a
  }) 
  let coins = 0;
  for(let i =0; i<N.length; i++){
    if(N[i]<=K){
      coins += Math.floor(K/N[i])
      K=K%N[i]
    }
  }
  return coins
}

coinChange([1,5,10,50,100,500,1000,5000,10000,50000],4200)